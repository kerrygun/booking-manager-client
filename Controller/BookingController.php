<?php

/**
 * BookingController
 * PHP version 8.1.1
 *
 * @category Class
 * @package  OpenAPI\Server\Controller
 * @author   OpenAPI Generator team
 * @link     https://github.com/openapitools/openapi-generator
 */

/**
 * Booking Manager API
 *
 * # Booking Manager API for Agencies and Charter Fleets  Booking Manager API is a standard Web service that enables clients to connect their data with external systems and services and to extend the automation benefits of the Booking Manager System. - It is used by charter agencies to publish availabilities of Charter Operators and automate booking processes by connecting Booking Manager to their own web sites to allow for seamless online booking experience for end users or integrating it with their CRM solutions in order to automate office procedures. - Charter operators use the web service to connect Booking Manager with their book keeping softwares and save time and effort in accounting department. - Third Party Software tools also use Booking Manager API to display richer information, for example boat tracking systems are able to visualise client contact information directly on the map showing the boat location in real time. ## Document Changes ### 29.05.2020 - `/companies` more information added in response - address, additional telephone and additional mobile number - `/offers` added `kind` parameter in the request - `/yachts` added `validForBases from/to` parameter to the response ### 10.04.2020   - `/yachts` added `shipyardId` parameter to the response - POST `/addDocument` - function to add document on specific item - `/offers` added `sailingAreaId` as additional parameter in request - PUT `/reservation` added `expirationDate` for options      ### 12.03.2020. - Extras valid for certain yacht in `/yachts` - `/yachts` function with extras duration parameter - `validDaysFrom`/`validDaysTo` - `/yachts` function with year of build `year`, default yacht deposit `deposit`, commision percentage `commissionPercentage` and default check in day `defaultCheckInDay` - `/yacht` field `lenghtAtWaterline` corrected to length
 *
 * The version of the OpenAPI document: 2.0.2
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 *
 */

/**
 * NOTE: This class is auto generated by the openapi generator program.
 * https://github.com/openapitools/openapi-generator
 * Do not edit the class manually.
 */

namespace OpenAPI\Server\Controller;

use \Exception;
use JMS\Serializer\Exception\RuntimeException as SerializerRuntimeException;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Exception\HttpException;
use Symfony\Component\Validator\Constraints as Assert;
use OpenAPI\Server\BookingManagerClient\BookingApiInterface;
use OpenAPI\Server\Model\AvailabilityResponse;
use OpenAPI\Server\Model\Base;
use OpenAPI\Server\Model\Company;
use OpenAPI\Server\Model\Country;
use OpenAPI\Server\Model\DocumentResponse;
use OpenAPI\Server\Model\Equipment;
use OpenAPI\Server\Model\Flexibility;
use OpenAPI\Server\Model\ItemTypeEnum;
use OpenAPI\Server\Model\Offer;
use OpenAPI\Server\Model\Price;
use OpenAPI\Server\Model\ProductEnum;
use OpenAPI\Server\Model\Reservation;
use OpenAPI\Server\Model\ReservationResponse;
use OpenAPI\Server\Model\SailingArea;
use OpenAPI\Server\Model\Shipyard;
use OpenAPI\Server\Model\ShortAvailability;
use OpenAPI\Server\Model\WorldRegion;
use OpenAPI\Server\Model\Yacht;

/**
 * BookingController Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Server\Controller
 * @author   OpenAPI Generator team
 * @link     https://github.com/openapitools/openapi-generator
 */
class BookingController extends Controller
{

    /**
     * Operation addDocuent
     *
     * Add document
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function addDocuentAction(Request $request, $itemType)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'bearerAuth' required
        // HTTP basic authentication required
        $securitybearerAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $id = $request->query->get('id');
        $description = $request->query->get('description');
        $document = $request->files->get('document');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $itemType = $this->deserialize($itemType, 'ItemTypeEnum', 'string');
            $id = $this->deserialize($id, 'int', 'string');
            $description = $this->deserialize($description, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("ItemTypeEnum");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($itemType, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($id, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($description, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\File();
        $response = $this->validate($document, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'bearerAuth'
            $handler->setbearerAuth($securitybearerAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->addDocuent($itemType, $id, $description, $document, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 201:
                    $message = 'HTTPS status Created. Returns reservation details';
                    break;
                case 400:
                    $message = 'Bad request.';
                    break;
                case 401:
                    $message = 'Authorization Bearer token is missing or invalid.';
                    break;
                case 422:
                    $message = 'Unprocessable obligatory field.';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation cancelReservation
     *
     * Cancel reservation
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function cancelReservationAction(Request $request, $reservationId)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'bearerAuth' required
        // HTTP basic authentication required
        $securitybearerAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $reservationId = $this->deserialize($reservationId, 'int', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($reservationId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'bearerAuth'
            $handler->setbearerAuth($securitybearerAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->cancelReservation($reservationId, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'returns a reservation details';
                    break;
                case 400:
                    $message = 'bad input parameter';
                    break;
                case 401:
                    $message = 'Authorization Bearer token is missing or invalid.';
                    break;
                case 404:
                    $message = 'Entity not found.';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation confirmReservation
     *
     * Confirm reservation
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function confirmReservationAction(Request $request, $reservationId)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'bearerAuth' required
        // HTTP basic authentication required
        $securitybearerAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $reservationId = $this->deserialize($reservationId, 'int', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($reservationId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'bearerAuth'
            $handler->setbearerAuth($securitybearerAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->confirmReservation($reservationId, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'returns a reservation details';
                    break;
                case 400:
                    $message = 'bad input parameter';
                    break;
                case 401:
                    $message = 'Authorization Bearer token is missing or invalid.';
                    break;
                case 404:
                    $message = 'Entity not found.';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation createReservation
     *
     * Create reservation
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function createReservationAction(Request $request)
    {
        // Make sure that the client is providing something that we can consume
        $consumes = ['application/json'];
        if (!static::isContentTypeAllowed($request, $consumes)) {
            // We can't consume the content that the client is sending us
            return new Response('', 415);
        }

        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'bearerAuth' required
        // HTTP basic authentication required
        $securitybearerAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $reservation = $request->getContent();

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $inputFormat = $request->getMimeType($request->getContentType());
            $reservation = $this->deserialize($reservation, 'OpenAPI\Server\Model\Reservation', $inputFormat);
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("OpenAPI\Server\Model\Reservation");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($reservation, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'bearerAuth'
            $handler->setbearerAuth($securitybearerAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->createReservation($reservation, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 201:
                    $message = 'HTTPS status Created. Returns reservation details';
                    break;
                case 400:
                    $message = 'Bad request.';
                    break;
                case 401:
                    $message = 'Authorization Bearer token is missing or invalid.';
                    break;
                case 422:
                    $message = 'Unprocessable obligatory field.';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getAvailability
     *
     * Gets availability
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getAvailabilityAction(Request $request, $year)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'bearerAuth' required
        // HTTP basic authentication required
        $securitybearerAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $companyId = $request->query->get('companyId');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $year = $this->deserialize($year, 'int', 'string');
            $companyId = $this->deserialize($companyId, 'int', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($year, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($companyId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'bearerAuth'
            $handler->setbearerAuth($securitybearerAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getAvailability($year, $companyId, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'All reservations are returned including canceled reservations and current offers that don&#39;t block availability.';
                    break;
                case 400:
                    $message = 'Bad request.';
                    break;
                case 401:
                    $message = 'Authorization Bearer token is missing or invalid.';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getBaseById
     *
     * Gets a specific base
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getBaseByIdAction(Request $request, $id)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'bearerAuth' required
        // HTTP basic authentication required
        $securitybearerAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $id = $this->deserialize($id, 'int', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($id, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'bearerAuth'
            $handler->setbearerAuth($securitybearerAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getBaseById($id, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'returns a matching base id with all detailed information.';
                    break;
                case 400:
                    $message = 'Bad request.';
                    break;
                case 401:
                    $message = 'Authorization Bearer token is missing or invalid.';
                    break;
                case 404:
                    $message = 'Entity not found.';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getBases
     *
     * Provides a list of bases
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getBasesAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'bearerAuth' required
        // HTTP basic authentication required
        $securitybearerAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Validate the input values


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'bearerAuth'
            $handler->setbearerAuth($securitybearerAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getBases($responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'returns a list of available bases with dedicated base description.';
                    break;
                case 400:
                    $message = 'Bad request.';
                    break;
                case 401:
                    $message = 'Authorization Bearer token is missing or invalid.';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getCompanies
     *
     * Provides a list of companies
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getCompaniesAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'bearerAuth' required
        // HTTP basic authentication required
        $securitybearerAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Validate the input values


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'bearerAuth'
            $handler->setbearerAuth($securitybearerAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getCompanies($responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Retrieves the list of all the Charter operators in the Booking Manager System who manage their resources *_/yachts* availability in real time. This list provides the id&#39;s of the companies that are available for synchronisation and for real time booking.';
                    break;
                case 400:
                    $message = 'Bad request.';
                    break;
                case 401:
                    $message = 'Authorization Bearer token is missing or invalid.';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getCompanyBy
     *
     * Gets a specific company
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getCompanyByAction(Request $request, $id)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'bearerAuth' required
        // HTTP basic authentication required
        $securitybearerAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $id = $this->deserialize($id, 'int', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($id, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'bearerAuth'
            $handler->setbearerAuth($securitybearerAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getCompanyBy($id, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'returns a matching company id';
                    break;
                case 400:
                    $message = 'Bad request.';
                    break;
                case 401:
                    $message = 'Authorization Bearer token is missing or invalid.';
                    break;
                case 404:
                    $message = 'Entity not found.';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getCountries
     *
     * Provides a list of countries
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getCountriesAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'bearerAuth' required
        // HTTP basic authentication required
        $securitybearerAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Validate the input values


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'bearerAuth'
            $handler->setbearerAuth($securitybearerAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getCountries($responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'returns a list of countries';
                    break;
                case 400:
                    $message = 'Bad request.';
                    break;
                case 401:
                    $message = 'Authorization Bearer token is missing or invalid.';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getCountryById
     *
     * Gets a specific country
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getCountryByIdAction(Request $request, $id)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'bearerAuth' required
        // HTTP basic authentication required
        $securitybearerAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $id = $this->deserialize($id, 'int', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($id, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'bearerAuth'
            $handler->setbearerAuth($securitybearerAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getCountryById($id, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'returns a matching country';
                    break;
                case 400:
                    $message = 'Bad request.';
                    break;
                case 401:
                    $message = 'Authorization Bearer token is missing or invalid.';
                    break;
                case 404:
                    $message = 'Entity not found.';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getEquipment
     *
     * Provides a list of equipment categories
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getEquipmentAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'bearerAuth' required
        // HTTP basic authentication required
        $securitybearerAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Validate the input values


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'bearerAuth'
            $handler->setbearerAuth($securitybearerAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getEquipment($responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'returns a list of equipment categories';
                    break;
                case 400:
                    $message = 'Bad request.';
                    break;
                case 401:
                    $message = 'Authorization Bearer token is missing or invalid.';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getOffers
     *
     * Provides a list of available offers
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getOffersAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'bearerAuth' required
        // HTTP basic authentication required
        $securitybearerAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $dateFrom = $request->query->get('dateFrom');
        $dateTo = $request->query->get('dateTo');
        $flexibility = $request->query->get('flexibility');
        $companyId = $request->query->get('companyId');
        $country = $request->query->get('country');
        $productName = $request->query->get('productName');
        $baseFromId = $request->query->get('baseFromId');
        $baseToId = $request->query->get('baseToId');
        $sailingAreaId = $request->query->get('sailingAreaId');
        $yachtId = $request->query->get('yachtId');
        $modelId = $request->query->get('modelId');
        $currency = $request->query->get('currency');
        $tripDuration = $request->query->get('tripDuration');
        $minCabins = $request->query->get('minCabins');
        $maxCabins = $request->query->get('maxCabins');
        $minBerths = $request->query->get('minBerths');
        $maxBerths = $request->query->get('maxBerths');
        $minHeads = $request->query->get('minHeads');
        $maxHeads = $request->query->get('maxHeads');
        $minLength = $request->query->get('minLength');
        $maxLength = $request->query->get('maxLength');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $dateFrom = $this->deserialize($dateFrom, '\DateTime', 'string');
            $dateTo = $this->deserialize($dateTo, '\DateTime', 'string');
            $flexibility = $this->deserialize($flexibility, 'Flexibility', 'string');
            $companyId = $this->deserialize($companyId, 'array<multi,int>', 'string');
            $country = $this->deserialize($country, 'array<multi,string>', 'string');
            $productName = $this->deserialize($productName, 'ProductEnum', 'string');
            $baseFromId = $this->deserialize($baseFromId, 'array<multi,int>', 'string');
            $baseToId = $this->deserialize($baseToId, 'array<multi,int>', 'string');
            $sailingAreaId = $this->deserialize($sailingAreaId, 'array<multi,int>', 'string');
            $yachtId = $this->deserialize($yachtId, 'array<multi,int>', 'string');
            $modelId = $this->deserialize($modelId, 'array<multi,int>', 'string');
            $currency = $this->deserialize($currency, 'string', 'string');
            $tripDuration = $this->deserialize($tripDuration, 'array<multi,int>', 'string');
            $minCabins = $this->deserialize($minCabins, 'int', 'string');
            $maxCabins = $this->deserialize($maxCabins, 'int', 'string');
            $minBerths = $this->deserialize($minBerths, 'int', 'string');
            $maxBerths = $this->deserialize($maxBerths, 'int', 'string');
            $minHeads = $this->deserialize($minHeads, 'int', 'string');
            $maxHeads = $this->deserialize($maxHeads, 'int', 'string');
            $minLength = $this->deserialize($minLength, 'float', 'string');
            $maxLength = $this->deserialize($maxLength, 'float', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\DateTime();
        $response = $this->validate($dateFrom, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\DateTime();
        $response = $this->validate($dateTo, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("Flexibility");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($flexibility, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("int"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($companyId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($country, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("ProductEnum");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($productName, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("int"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($baseFromId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("int"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($baseToId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("int"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($sailingAreaId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("int"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($yachtId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("int"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($modelId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($currency, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("int"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($tripDuration, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($minCabins, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($maxCabins, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($minBerths, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($maxBerths, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($minHeads, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($maxHeads, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("float");
        $response = $this->validate($minLength, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("float");
        $response = $this->validate($maxLength, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'bearerAuth'
            $handler->setbearerAuth($securitybearerAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getOffers($dateFrom, $dateTo, $flexibility, $companyId, $country, $productName, $baseFromId, $baseToId, $sailingAreaId, $yachtId, $modelId, $currency, $tripDuration, $minCabins, $maxCabins, $minBerths, $maxBerths, $minHeads, $maxHeads, $minLength, $maxLength, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'returns a list of yachts';
                    break;
                case 400:
                    $message = 'Bad request.';
                    break;
                case 401:
                    $message = 'Authorization Bearer token is missing or invalid.';
                    break;
                case 422:
                    $message = 'Unprocessable obligatory field.';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getPrices
     *
     * Provides a list of yacht prices
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getPricesAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'bearerAuth' required
        // HTTP basic authentication required
        $securitybearerAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $dateFrom = $request->query->get('dateFrom');
        $dateTo = $request->query->get('dateTo');
        $companyId = $request->query->get('companyId');
        $country = $request->query->get('country');
        $productName = $request->query->get('productName');
        $yachtId = $request->query->get('yachtId');
        $currency = $request->query->get('currency');
        $tripDuration = $request->query->get('tripDuration');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $dateFrom = $this->deserialize($dateFrom, '\DateTime', 'string');
            $dateTo = $this->deserialize($dateTo, '\DateTime', 'string');
            $companyId = $this->deserialize($companyId, 'array<multi,int>', 'string');
            $country = $this->deserialize($country, 'array<multi,string>', 'string');
            $productName = $this->deserialize($productName, 'ProductEnum', 'string');
            $yachtId = $this->deserialize($yachtId, 'array<multi,int>', 'string');
            $currency = $this->deserialize($currency, 'string', 'string');
            $tripDuration = $this->deserialize($tripDuration, 'array<multi,int>', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\DateTime();
        $response = $this->validate($dateFrom, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\DateTime();
        $response = $this->validate($dateTo, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("int"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($companyId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($country, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("ProductEnum");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($productName, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("int"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($yachtId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($currency, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("int"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($tripDuration, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'bearerAuth'
            $handler->setbearerAuth($securitybearerAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getPrices($dateFrom, $dateTo, $companyId, $country, $productName, $yachtId, $currency, $tripDuration, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Response will return final yacht price with discount for requested period. There are multiple filters that can be selected in the request to specify the request to get more precise response.';
                    break;
                case 400:
                    $message = 'Bad request.';
                    break;
                case 401:
                    $message = 'Authorization Bearer token is missing or invalid.';
                    break;
                case 422:
                    $message = 'Unprocessable obligatory field.';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getReservation
     *
     * Get reservation
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getReservationAction(Request $request, $reservationId)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'bearerAuth' required
        // HTTP basic authentication required
        $securitybearerAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $reservationId = $this->deserialize($reservationId, 'int', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($reservationId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'bearerAuth'
            $handler->setbearerAuth($securitybearerAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getReservation($reservationId, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'returns a reservation details';
                    break;
                case 400:
                    $message = 'bad input parameter';
                    break;
                case 401:
                    $message = 'Authorization Bearer token is missing or invalid.';
                    break;
                case 404:
                    $message = 'Entity not found.';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getReservations
     *
     * Retrieves all reservations, including cancelled reservations
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getReservationsAction(Request $request, $year)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'bearerAuth' required
        // HTTP basic authentication required
        $securitybearerAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $status = $request->query->get('status');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $year = $this->deserialize($year, 'int', 'string');
            $status = $this->deserialize($status, 'int', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($year, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($status, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'bearerAuth'
            $handler->setbearerAuth($securitybearerAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getReservations($year, $status, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'returns a list of all reservations with all dedicated detailed information.';
                    break;
                case 400:
                    $message = 'Bad request.';
                    break;
                case 401:
                    $message = 'Authorization Bearer token is missing or invalid.';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getSailingAreaById
     *
     * Gets a specific sailing area
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getSailingAreaByIdAction(Request $request, $id)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'bearerAuth' required
        // HTTP basic authentication required
        $securitybearerAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $id = $this->deserialize($id, 'int', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($id, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'bearerAuth'
            $handler->setbearerAuth($securitybearerAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getSailingAreaById($id, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'returns a matching sailing area';
                    break;
                case 400:
                    $message = 'Bad request.';
                    break;
                case 401:
                    $message = 'Authorization Bearer token is missing or invalid.';
                    break;
                case 404:
                    $message = 'Entity not found.';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getSailingAreas
     *
     * Provides a list of sailing areas
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getSailingAreasAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'bearerAuth' required
        // HTTP basic authentication required
        $securitybearerAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Validate the input values


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'bearerAuth'
            $handler->setbearerAuth($securitybearerAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getSailingAreas($responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'returns a list of sailing areas';
                    break;
                case 400:
                    $message = 'Bad request.';
                    break;
                case 401:
                    $message = 'Authorization Bearer token is missing or invalid.';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getShipyardById
     *
     * Gets a specific shipyard
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getShipyardByIdAction(Request $request, $id)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'bearerAuth' required
        // HTTP basic authentication required
        $securitybearerAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $id = $this->deserialize($id, 'int', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($id, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'bearerAuth'
            $handler->setbearerAuth($securitybearerAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getShipyardById($id, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'returns a matching shipyard id';
                    break;
                case 400:
                    $message = 'Bad request.';
                    break;
                case 401:
                    $message = 'Authorization Bearer token is missing or invalid.';
                    break;
                case 404:
                    $message = 'Entity not found.';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getShipyards
     *
     * Provides a list of shipyards
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getShipyardsAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'bearerAuth' required
        // HTTP basic authentication required
        $securitybearerAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Validate the input values


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'bearerAuth'
            $handler->setbearerAuth($securitybearerAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getShipyards($responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Returns a list of boat shipyards.';
                    break;
                case 400:
                    $message = 'Bad request.';
                    break;
                case 401:
                    $message = 'Authorization Bearer token is missing or invalid.';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getShortAvailability
     *
     * Gets shortAvailability
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getShortAvailabilityAction(Request $request, $year)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'bearerAuth' required
        // HTTP basic authentication required
        $securitybearerAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $companyId = $request->query->get('companyId');
        $yachtId = $request->query->get('yachtId');
        $format = $request->query->get('format');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $year = $this->deserialize($year, 'int', 'string');
            $companyId = $this->deserialize($companyId, 'int', 'string');
            $yachtId = $this->deserialize($yachtId, 'int', 'string');
            $format = $this->deserialize($format, 'int', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($year, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($companyId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($yachtId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Choice([ 1, 2, 3 ]);
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($format, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'bearerAuth'
            $handler->setbearerAuth($securitybearerAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getShortAvailability($year, $companyId, $yachtId, $format, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'returns a short availability. There are several status codes - **0** Available  - **1** Reservation  - **2** Option - **3** Option in expiration - **4** Service';
                    break;
                case 400:
                    $message = 'Bad request.';
                    break;
                case 401:
                    $message = 'Authorization Bearer token is missing or invalid.';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getSpecialOffers
     *
     * Provides a list of special offers
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getSpecialOffersAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'bearerAuth' required
        // HTTP basic authentication required
        $securitybearerAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $dateFrom = $request->query->get('dateFrom');
        $flexibility = $request->query->get('flexibility');
        $companyId = $request->query->get('companyId');
        $country = $request->query->get('country');
        $productName = $request->query->get('productName');
        $baseFromId = $request->query->get('baseFromId');
        $baseToId = $request->query->get('baseToId');
        $yachtId = $request->query->get('yachtId');
        $modelId = $request->query->get('modelId');
        $currency = $request->query->get('currency');
        $tripDuration = $request->query->get('tripDuration');
        $minCabins = $request->query->get('minCabins');
        $maxCabins = $request->query->get('maxCabins');
        $minBerths = $request->query->get('minBerths');
        $maxBerths = $request->query->get('maxBerths');
        $minHeads = $request->query->get('minHeads');
        $maxHeads = $request->query->get('maxHeads');
        $minLength = $request->query->get('minLength');
        $maxLength = $request->query->get('maxLength');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $dateFrom = $this->deserialize($dateFrom, '\DateTime', 'string');
            $flexibility = $this->deserialize($flexibility, 'Flexibility', 'string');
            $companyId = $this->deserialize($companyId, 'array<multi,int>', 'string');
            $country = $this->deserialize($country, 'array<multi,string>', 'string');
            $productName = $this->deserialize($productName, 'ProductEnum', 'string');
            $baseFromId = $this->deserialize($baseFromId, 'array<multi,int>', 'string');
            $baseToId = $this->deserialize($baseToId, 'array<multi,int>', 'string');
            $yachtId = $this->deserialize($yachtId, 'array<multi,int>', 'string');
            $modelId = $this->deserialize($modelId, 'array<multi,int>', 'string');
            $currency = $this->deserialize($currency, 'string', 'string');
            $tripDuration = $this->deserialize($tripDuration, 'array<multi,int>', 'string');
            $minCabins = $this->deserialize($minCabins, 'int', 'string');
            $maxCabins = $this->deserialize($maxCabins, 'int', 'string');
            $minBerths = $this->deserialize($minBerths, 'int', 'string');
            $maxBerths = $this->deserialize($maxBerths, 'int', 'string');
            $minHeads = $this->deserialize($minHeads, 'int', 'string');
            $maxHeads = $this->deserialize($maxHeads, 'int', 'string');
            $minLength = $this->deserialize($minLength, 'float', 'string');
            $maxLength = $this->deserialize($maxLength, 'float', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\DateTime();
        $response = $this->validate($dateFrom, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("Flexibility");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($flexibility, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("int"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($companyId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($country, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("ProductEnum");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($productName, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("int"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($baseFromId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("int"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($baseToId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("int"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($yachtId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("int"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($modelId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($currency, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("int"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($tripDuration, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($minCabins, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($maxCabins, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($minBerths, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($maxBerths, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($minHeads, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($maxHeads, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("float");
        $response = $this->validate($minLength, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("float");
        $response = $this->validate($maxLength, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'bearerAuth'
            $handler->setbearerAuth($securitybearerAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getSpecialOffers($dateFrom, $flexibility, $companyId, $country, $productName, $baseFromId, $baseToId, $yachtId, $modelId, $currency, $tripDuration, $minCabins, $maxCabins, $minBerths, $maxBerths, $minHeads, $maxHeads, $minLength, $maxLength, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'returns a list of available yachts for requested special offer';
                    break;
                case 400:
                    $message = 'Bad request.';
                    break;
                case 401:
                    $message = 'Authorization Bearer token is missing or invalid.';
                    break;
                case 422:
                    $message = 'Unprocessable obligatory field.';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getSpecialOffersByType
     *
     * Provides a list of special offers
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getSpecialOffersByTypeAction(Request $request, $offerType)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'bearerAuth' required
        // HTTP basic authentication required
        $securitybearerAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $dateFrom = $request->query->get('dateFrom');
        $flexibility = $request->query->get('flexibility');
        $companyId = $request->query->get('companyId');
        $country = $request->query->get('country');
        $productName = $request->query->get('productName');
        $baseFromId = $request->query->get('baseFromId');
        $baseToId = $request->query->get('baseToId');
        $sailingAreaId = $request->query->get('sailingAreaId');
        $yachtId = $request->query->get('yachtId');
        $modelId = $request->query->get('modelId');
        $currency = $request->query->get('currency');
        $tripDuration = $request->query->get('tripDuration');
        $minCabins = $request->query->get('minCabins');
        $maxCabins = $request->query->get('maxCabins');
        $minBerths = $request->query->get('minBerths');
        $maxBerths = $request->query->get('maxBerths');
        $minHeads = $request->query->get('minHeads');
        $maxHeads = $request->query->get('maxHeads');
        $minLength = $request->query->get('minLength');
        $maxLength = $request->query->get('maxLength');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $offerType = $this->deserialize($offerType, 'string', 'string');
            $dateFrom = $this->deserialize($dateFrom, '\DateTime', 'string');
            $flexibility = $this->deserialize($flexibility, 'Flexibility', 'string');
            $companyId = $this->deserialize($companyId, 'array<multi,int>', 'string');
            $country = $this->deserialize($country, 'array<multi,string>', 'string');
            $productName = $this->deserialize($productName, 'ProductEnum', 'string');
            $baseFromId = $this->deserialize($baseFromId, 'array<multi,int>', 'string');
            $baseToId = $this->deserialize($baseToId, 'array<multi,int>', 'string');
            $sailingAreaId = $this->deserialize($sailingAreaId, 'array<multi,int>', 'string');
            $yachtId = $this->deserialize($yachtId, 'array<multi,int>', 'string');
            $modelId = $this->deserialize($modelId, 'array<multi,int>', 'string');
            $currency = $this->deserialize($currency, 'string', 'string');
            $tripDuration = $this->deserialize($tripDuration, 'array<multi,int>', 'string');
            $minCabins = $this->deserialize($minCabins, 'int', 'string');
            $maxCabins = $this->deserialize($maxCabins, 'int', 'string');
            $minBerths = $this->deserialize($minBerths, 'int', 'string');
            $maxBerths = $this->deserialize($maxBerths, 'int', 'string');
            $minHeads = $this->deserialize($minHeads, 'int', 'string');
            $maxHeads = $this->deserialize($maxHeads, 'int', 'string');
            $minLength = $this->deserialize($minLength, 'float', 'string');
            $maxLength = $this->deserialize($maxLength, 'float', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Choice([ "all", "oneway", "shortoffers" ]);
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($offerType, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\DateTime();
        $response = $this->validate($dateFrom, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("Flexibility");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($flexibility, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("int"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($companyId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($country, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("ProductEnum");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($productName, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("int"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($baseFromId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("int"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($baseToId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("int"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($sailingAreaId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("int"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($yachtId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("int"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($modelId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($currency, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("int"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($tripDuration, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($minCabins, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($maxCabins, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($minBerths, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($maxBerths, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($minHeads, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($maxHeads, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("float");
        $response = $this->validate($minLength, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("float");
        $response = $this->validate($maxLength, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'bearerAuth'
            $handler->setbearerAuth($securitybearerAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getSpecialOffersByType($offerType, $dateFrom, $flexibility, $companyId, $country, $productName, $baseFromId, $baseToId, $sailingAreaId, $yachtId, $modelId, $currency, $tripDuration, $minCabins, $maxCabins, $minBerths, $maxBerths, $minHeads, $maxHeads, $minLength, $maxLength, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'returns a list of yachts';
                    break;
                case 400:
                    $message = 'Bad request.';
                    break;
                case 401:
                    $message = 'Authorization Bearer token is missing or invalid.';
                    break;
                case 422:
                    $message = 'Unprocessable obligatory field.';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getWorldRegionById
     *
     * Gets a specific world region
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getWorldRegionByIdAction(Request $request, $id)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'bearerAuth' required
        // HTTP basic authentication required
        $securitybearerAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $id = $this->deserialize($id, 'int', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($id, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'bearerAuth'
            $handler->setbearerAuth($securitybearerAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getWorldRegionById($id, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'returns a matching world region';
                    break;
                case 400:
                    $message = 'Bad request.';
                    break;
                case 401:
                    $message = 'Authorization Bearer token is missing or invalid.';
                    break;
                case 404:
                    $message = 'Entity not found.';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getWorldRegions
     *
     * Provides a list of world regions
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getWorldRegionsAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'bearerAuth' required
        // HTTP basic authentication required
        $securitybearerAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Validate the input values


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'bearerAuth'
            $handler->setbearerAuth($securitybearerAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getWorldRegions($responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'returns a list of world regions';
                    break;
                case 400:
                    $message = 'Bad request.';
                    break;
                case 401:
                    $message = 'Authorization Bearer token is missing or invalid.';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getYachts
     *
     * Provides a list of yachts
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getYachtsAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'bearerAuth' required
        // HTTP basic authentication required
        $securitybearerAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $companyId = $request->query->get('companyId');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $companyId = $this->deserialize($companyId, 'int', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($companyId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'bearerAuth'
            $handler->setbearerAuth($securitybearerAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getYachts($companyId, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Explanation of the response structure &lt;br /&gt;&lt;br /&gt; First part  of the response contains technical info of the boat  &lt;br /&gt;&lt;br /&gt; id &#x3D; unique resource id&lt;br /&gt; name &#x3D; the name of the individual yacht&lt;br /&gt; model&#x3D; name of the model&lt;br /&gt; shipyardID&#x3D; id of the shipyard (boat manufacturer)&lt;br /&gt;';
                    break;
                case 400:
                    $message = 'Bad request.';
                    break;
                case 401:
                    $message = 'Authorization Bearer token is missing or invalid.';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getYacthById
     *
     * Gets a specific yacht
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getYacthByIdAction(Request $request, $id)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'bearerAuth' required
        // HTTP basic authentication required
        $securitybearerAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $id = $this->deserialize($id, 'int', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($id, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'bearerAuth'
            $handler->setbearerAuth($securitybearerAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getYacthById($id, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'returns a matching yacht id';
                    break;
                case 400:
                    $message = 'Bad request.';
                    break;
                case 401:
                    $message = 'Authorization Bearer token is missing or invalid.';
                    break;
                case 404:
                    $message = 'Entity not found.';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Returns the handler for this API controller.
     * @return BookingApiInterface
     */
    public function getApiHandler()
    {
        return $this->apiServer->getApiHandler('booking');
    }
}
